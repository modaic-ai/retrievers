---
title: VDB Alchemy
---

# VDB Alchemy

Modaic provides an ORM-like layer for vector databases called VDB Alchemy. With a single `VectorDatabase` abstraction, you can create, load, and search collections of any `Context` objects. Configure a provider by passing a `VectorDBBackend` to `VectorDatabase`. The Milvus provider is currently supported (both Milvus Server and Milvus Lite via `MilvusBackend.from_local("path.db")`). You can optionally set a default `Embedder` and a default `payload_class` (a `Context` subclass) on the connection; these defaults apply unless overridden.


### Install
VDB Alchemy relies on `pymilvus` and optionally `pillow` for image queries. They are already specified in `pyproject.toml`; if you need to install manually:
```bash
uv add pymilvus pillow
```


## Backends

### MilvusBackend
Connect to Milvus Lite (single-file local) or Milvus Server.
```python
from modaic.databases import VectorDatabase, MilvusBackend
from modaic.indexing import DummyEmbedder
from modaic.context.table import TableFile

# Defaults for this connection (used unless overridden per collection)
embedder = DummyEmbedder()

# Milvus Lite (local file)
vdb_lite = VectorDatabase(MilvusBackend.from_local("index.db"), embedder=embedder, payload_class=TableFile)

# Milvus Server
vdb_srv = VectorDatabase(
    MilvusBackend(uri="http://localhost:19530", user="", password="", db_name=""),
    embedder=embedder,
    payload_class=TableFile,
)
```


## Quickstart

Create a connection, create/load a collection, add records, and search.
```python
from pathlib import Path
import os

from modaic.databases import VectorDatabase, MilvusBackend
from modaic.indexing import DummyEmbedder
from modaic.context.table import TableFile

embedder = DummyEmbedder()
vdb = VectorDatabase(MilvusBackend.from_local("index.db"), embedder=embedder, payload_class=TableFile)

# 1) Create a collection (exists_behavior="replace" | "fail")
vdb.create_collection("table_rag", TableFile, exists_behavior="replace")

# 2) Add records
directory = "examples/TableRAG/dev_excel"
tables = [
    TableFile.from_file(name, Path(os.path.join(directory, name)), file_type="xlsx")
    for name in os.listdir(directory)
]
vdb.add_records("table_rag", tables)

# 3) Search (string or image)
results = vdb.search("table_rag", "test", k=3)
top_hit = results[0][0]
top_hit_id = top_hit["id"]
top_hit_distance = top_hit["distance"]
top_hit_context = top_hit["context"]

# 4) Load an existing collection
vdb.load_collection("table_rag", TableFile)
```

Change the default embedder later if needed:
```python
from modaic.indexing import DummyEmbedder
vdb.set_embedder(DummyEmbedder())
```


## Adding Records

### From an iterable of `Context`
Embeddings are generated automatically from each contextâ€™s `embedme()`.
```python
vdb.add_records("table_rag", tables)
```

### From a generator
`VectorDatabase.add_records()` accepts any iterable, including generators. Optionally batch and show a progress bar.
```python
def records_generator():
    directory = "examples/TableRAG/dev_excel"
    for name in os.listdir(directory):
        file_path = os.path.join(directory, name)
        yield TableFile.from_file(name, Path(file_path), file_type="xlsx")

vdb.add_records("table_rag", records_generator(), batch_size=200, tqdm_total=len(os.listdir("examples/TableRAG/dev_excel")))
```

### With custom embedme strings/images
Override the text or image used to embed a record by passing `(embedme, context)` tuples.
```python
records_with_custom_embedmes = [(str(table.schema_info()), table) for table in tables]
vdb.add_records("table_rag", records_with_custom_embedmes)
```

### Multiple embedme per record (advanced)
If your `Context` implements `embedme(index_name)` (i.e., different embedmes per index), set `embedme_scope="index"` or leave `"auto"` to detect automatically.
```python
vdb.add_records("table_rag", tables, embedme_scope="index")
```


## Searching

Search with a string or image; returns a list of ranked matches per query.
```python
results = vdb.search("table_rag", "test", k=3)
first_query_top = results[0][0]  # {"id", "distance", "context"}
```

### Filters
#### Using the Modaic Query Language
Use the Modaic Query Language:
```python
from modaic.context.table import TableFile

results = vdb.search(
    "table_rag",
    "test",
    k=3,
    filter=TableFile.file_type == "xlsx",
)
```

#### Using `Prop`, `Value`, `AND` and `OR`
You can also build filters manually using `Prop`, `Value`, `AND` and `OR`.
```python
from modaic.databases import Prop, Value, AND, OR
filter1 = Prop("file_type") == "xlsx"
# Same as Prop("file_type") == Value("xlsx")
filter2 = Prop("file_type") == "csv"
filter3 = Prop("file_type") == "json"
my_filter = filter1 & (filter2 | filter3)
# Same as my_filter = AND(filter1, OR(filter2, filter3))
results = vdb.search("table_rag", "test", k=3, filter={"file_type": "xlsx"})
```
#### Using Backend's native filtering language
If modaic doesnt expose a specific operator for you vector database backend, you can always use the backend's native filtering language by directly accessing the backend's search method.
```python
from modaic.context.table import TableFile
from modaic.databases import MilvusBackend, VectorDatabase
vdb = VectorDatabase(MilvusBackend.from_local("index.db"))
# When using backend.search, you also need to pass the payload_class to the search method.
results = vdb.ext.backend.search("table_rag", "test", k=3, payload_class=TableFile, filter='file_type == "xlsx"')
```

### Multiple queries
Provide a list of queries. The return value is a list of result lists, one per query.
```python
results = vdb.search("table_rag", ["test", "test2"], k=1)
```


## Managing Collections
```python
# Drop
vdb.drop_collection("table_rag")

# List
collections = vdb.list_collections()

# Exists
exists = vdb.has_collection("table_rag")
```


## Get Records by IDs
Use the provider via `vdb.ext.backend` to fetch records by IDs with the correct `payload_class`.
```python
from modaic.context.table import TableFile

records = vdb.ext.backend.get_records(
    "table_rag",
    TableFile,
    ["3c92e055-17fd-44fa-9b5d-91a52f3028de"],
)
```


## Underlying Client
Access the native client (e.g., `MilvusClient`) if needed:
```python
client = vdb.ext.client
```


## Indexes and Metrics
Customize vector type, index type, metric, and embedder when creating a collection.
```python
from modaic.databases import IndexType, Metric, VectorType

vdb.create_collection(
    "table_rag",
    TableFile,
    vector_type=VectorType.FLOAT,
    index_type=IndexType.HNSW,
    metric=Metric.DOT_PRODUCT,
)
```
## Vector Database Extensions
Some providers expose additional capabilities (e.g., hybrid search, BM25) via `vdb.ext`. Availability varies by backend.

### Type Hints
The type hint for the generic `VectorDatabase` class is as follows:
```python
def vdb_func(vdb: VectorDatabase):
```
This means that you can pass any `VectorDatabase` instance to the function.

For more specific type hints, you can use `VectorDatabase[T]` where `T` is a `VectorDBBackend` protocol or class following the `VectorDBBackend` protocol.
For example:
```python
def vdb_func(vdb: VectorDatabase[MilvusBackend]):
    ...
```
This means that this function only works with vector databases using `MilvusBackend`.

```python
def vdb_func(vdb: VectorDatabase[SupportsHybridSearch]):
    ...
```
This means that this function only works with vector databases that support hybrid search.

You can even do compound protocol checks:
```python
class SupportsHybridAndBM25(SupportsHybridSearch, SupportsBM25):
    pass
def vdb_func(vdb: VectorDatabase[SupportsHybridAndBM25]):
    ...
```
This means that this function only works with vector databases that support hybrid search and BM25.

VectorDatabase and VectorDBBackend type hints are an quick and easy way to check if a vector database supports a certain extension. If you try to use an extension that the vector database doesn't support, your type checker will show that an error will be thrown.

## API Summary

- `VectorDatabase(backend: VectorDBBackend, embedder: Embedder | None = None, payload_class: type[Context] | None = None)`
  - Holds defaults for `embedder` and `payload_class`
- `create_collection(name: str, payload_class: type[Context], metric: Metric = Metric.COSINE, index_type: IndexType = IndexType.DEFAULT, vector_type: VectorType = VectorType.FLOAT, embedder: Embedder | None = None, exists_behavior: Literal["fail","replace"] = "replace")`
- `load_collection(name: str, payload_class: type[Context], embedder: Embedder | dict[str, Embedder] | None = None)`
- `add_records(name: str, records: Iterable[Context | tuple[str | Image.Image, Context]], batch_size: int | None = None, embedme_scope: Literal["auto","context","index"] = "auto", tqdm_total: int | None = None)`
- `search(name: str, query: str | Image.Image | list[str] | list[Image.Image], k: int = 10, filter: dict | QueryParam | None = None) -> list[list[SearchResult]]`
- `list_collections() -> list[str]`
- `drop_collection(name: str)` / `has_collection(name: str) -> bool`
- `set_embedder(embedder: Embedder)`
- Extensions via `vdb.ext`: `client`, backend-specific ops (availability varies)


### See also
- `modaic.context.table.Table` and `TableFile` for creating tabular Contexts
- Query Language docs for expressive filtering