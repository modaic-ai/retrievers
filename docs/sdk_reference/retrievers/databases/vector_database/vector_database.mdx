---
title: VectorDatabase Class
description: The Vector Database Class
---

## VectorType

```python
class VectorType(AutoNumberEnum)
```

#### FLOAT

float32

## IndexType

```python
class IndexType(AutoNumberEnum)
```

The ANN or ENN algorithm to use for an index. IndexType.DEFAULT is IndexType.HNSW for most vector databases (milvus, qdrant, mongo).

## Metric

```python
class Metric(AutoNumberEnum)
```

#### \_init\_

mapping of the library that supports the metric and the name the library uses to refer to it

## IndexConfig

```python
@dataclass
class IndexConfig()
```

Configuration for a VDB index.

**Arguments**:

- `vector_type` - The type of vector used by the index.
- `index_type` - The type of index to use. see IndexType for available options.
- `metric` - The metric to use for the index. see Metric for available options.
- `embedder` - The embedder to use for the index. If not provided, will use the VectorDatabase's embedder.

## VectorDatabase

```python
class VectorDatabase(Generic[TBackend], Trackable)
```

#### \_\_init\_\_

```python
def __init__(backend: TBackend,
             embedder: Optional[Embedder] = None,
             payload_class: Optional[Type[Context]] = None,
             **kwargs)
```

Initialize a vanilla vector database. This is a base class for all vector databases. If you need more functionality from a specific vector database, you should use a specific subclass.

**Arguments**:

- `config` - The configuration for the vector database
- `embedder` - The embedder to use for the vector database
- `payload_class` - The default context class for collections
- `**kwargs` - Additional keyword arguments

#### load\_collection

```python
def load_collection(collection_name: str,
                    payload_class: Type[Context],
                    embedder: Optional[Embedder | Dict[str, Embedder]] = None)
```

Load collection information into the vector database.

**Arguments**:

- `collection_name` - The name of the collection to load
- `payload_class` - The context class of the context objects stored in the collection
- `index` - The index configuration for the collection

#### create\_collection

```python
def create_collection(collection_name: str,
                      payload_class: Type[Context],
                      metric: Metric = Metric.COSINE,
                      index_type: IndexType = IndexType.DEFAULT,
                      vector_type: VectorType = VectorType.FLOAT,
                      embedder: Optional[Embedder] = None,
                      exists_behavior: Literal["fail", "replace"] = "replace")
```

Create a collection in the vector database.

**Arguments**:

- `collection_name` - The name of the collection to create
- `payload_class` - The class of the context objects stored in the collection
- `exists_behavior` - The behavior when the collection already exists

#### add\_records

```python
def add_records(collection_name: str,
                records: Iterable[Embeddable
                                  | Tuple[str | Image.Image, Context]],
                batch_size: Optional[int] = None,
                embedme_scope: Literal["auto", "context", "index"] = "auto",
                tqdm_total: Optional[int] = None)
```

Add items to a collection in the vector database.
Uses the Context's get_embed_context() method and the embedder to create embeddings.

**Arguments**:

- `collection_name` - The name of the collection to add records to
- `records` - The records to add to the collection
- `batch_size` - Optional batch size for processing records

#### has\_collection

```python
def has_collection(collection_name: str) -> bool
```

Check if a collection exists in the vector database.

**Arguments**:

- `collection_name` - The name of the collection to check
  

**Returns**:

  True if the collection exists, False otherwise

#### search

```python
@track_modaic_obj
def search(collection_name: str,
           query: str | Image.Image | List[str] | List[Image.Image],
           k: int = 10,
           filter: Optional[Condition] = None) -> List[List[SearchResult]]
```

Retrieve records from the vector database.
Returns a list of SearchResult dictionaries
SearchResult is a NamedTuple with the following keys:
- id: The id of the record
- distance: The distance of the record
- context: The context object (unhydrated if its hydratable)

**Arguments**:

- `collection_name` - The name of the collection to search
- `query` - The vector to search with
- `k` - The number of results to return
- `filter` - Optional filter to apply to the search
  

**Returns**:

- `results` - List of SearchResult dictionaries matching the search.
  

**Example**:

    ```python
    results = vdb.search("collection 1", "How do I bake an apple pie?", k=10)
    print(results[0][0].context)
    >>> <Context: Text(text="apple pie recipe is 2 cups of flour, 1 cup of sugar, 1 cup of milk, 1 cup of eggs, 1 cup of butter")>
    ```

#### get\_records

```python
def get_records(collection_name: str, record_id: List[str]) -> List[Context]
```

Get a record from the vector database.

**Arguments**:

- `collection_name` - The name of the collection
- `record_id` - The ID of the record to retrieve
  

**Returns**:

  The serialized context record.

#### hybrid\_search

```python
def hybrid_search(collection_name: str,
                  vectors: List[np.ndarray],
                  index_names: List[str],
                  k: int = 10) -> List[Context]
```

Hybrid search the vector database.

#### query

```python
def query(query: str,
          k: int = 10,
          filter: Optional[dict] = None) -> List[Context]
```

Query the vector database.

**Arguments**:

- `query` - The query string
- `k` - The number of results to return
- `filter` - Optional filter to apply to the query
  

**Returns**:

  List of serialized contexts matching the query.

#### upsert\_records

```python
def upsert_records(collection_name: str, records: Iterable[Context])
```

Upsert a record into the vector database.

#### delete\_records

```python
def delete_records(collection_name: str, context_ids: Iterable[str])
```

Delete a record from the vector database.

